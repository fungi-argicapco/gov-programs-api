#!/usr/bin/env bun
import { readFileSync, writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

const DATA_DIR = join(process.cwd(), 'data', 'government_programs');
const DATA_FILE = join(DATA_DIR, 'programs_dataset.csv');
const OUTPUT_FILE = join(process.cwd(), 'apps', 'ingest', 'src', 'datasets', 'government_programs.ts');

function ensureOutputDir() {
  mkdirSync(join(process.cwd(), 'apps', 'ingest', 'src', 'datasets'), { recursive: true });
}

type CsvRow = Record<string, string>;

function parseCsv(content: string): CsvRow[] {
  const rows: CsvRow[] = [];
  const lines = content.split(/\r?\n/);
  if (lines.length === 0) return rows;
  const header = parseLine(lines[0]);
  for (let i = 1; i < lines.length; i += 1) {
    const line = lines[i];
    if (!line.trim()) continue;
    const values = parseLine(line);
    const record: CsvRow = {};
    for (let j = 0; j < header.length; j += 1) {
      record[header[j]] = values[j] ?? '';
    }
    rows.push(record);
  }
  return rows;
}

function parseLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];
    if (inQuotes) {
      if (char === '"') {
        if (line[i + 1] === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
  }
  result.push(current);
  return result;
}

function inferTypeSample(rows: CsvRow[]): CsvRow {
  return rows[0] ?? {};
}

function inferTsType(value: string): string {
  return 'string';
}

function emitType(name: string, sample: CsvRow): string {
  const fields = Object.keys(sample).map((key) => `  ${key}: ${inferTsType(sample[key])};`);
  return `export type ${name} = {
${fields.join('\n')}
};`;
}

function formatValue(value: string): string {
  const escaped = value.replace(/`/g, '\\`');
  return `\`${escaped}\``;
}

function serializeRows(rows: CsvRow[]): string[] {
  return rows.map((row) => {
    const parts = Object.entries(row).map(([key, value]) => `  ${key}: ${formatValue(value)}`);
    return `{
${parts.join(',\n')}
}`;
  });
}

function main() {
  ensureOutputDir();
  const csv = readFileSync(DATA_FILE, 'utf8');
  const rows = parseCsv(csv);
  if (rows.length === 0) {
    throw new Error('programs_dataset.csv produced no rows');
  }
  const typeDef = emitType('GovernmentProgramEntry', inferTypeSample(rows));
  const objects = serializeRows(rows);
  const output = `// Auto-generated by scripts/generate-government-programs-dataset.ts\n// Do not edit by hand.\n\n${typeDef}\n\nexport const GOVERNMENT_PROGRAMS: readonly GovernmentProgramEntry[] = [\n${objects.join(',\n')}\n];\n`;
  writeFileSync(OUTPUT_FILE, output, 'utf8');
}

main();
