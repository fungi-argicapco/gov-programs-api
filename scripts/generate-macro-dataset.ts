#!/usr/bin/env bun
import { readFileSync, writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';

const DATA_DIR = join(process.cwd(), 'data', 'macro_metrics_global');
const DATA_FILE = join(DATA_DIR, 'macro_metric_seed_dataset.csv');
const SOURCE_FILE = join(DATA_DIR, 'source_registry.csv');
const OUTPUT_FILE = join(process.cwd(), 'apps', 'ingest', 'src', 'datasets', 'macro_global.ts');

if (!DATA_DIR) {
  throw new Error('DATA_DIR not resolved');
}

function ensureDatasetDir() {
  mkdirSync(join(process.cwd(), 'apps', 'ingest', 'src', 'datasets'), { recursive: true });
}

type CsvRow = Record<string, string>;

type MacroEntry = {
  unit: string;
  parent_iso3: string;
  metric: string;
  year: string;
  value: string;
  unit_measure: string;
  precision: string;
  methodology_notes: string;
};

type ServiceEntry = {
  metric: string;
  endpoint: string;
  parameters_or_payload: string;
  authentication: string;
  rate_limits: string;
  update_cadence: string;
  change_detection: string;
  status_page: string;
  automation_readiness: string;
  source_url: string;
  verification_date: string;
  notes: string;
};

function parseCsv(content: string): CsvRow[] {
  const rows: CsvRow[] = [];
  const lines = content.split(/\r?\n/);
  if (lines.length === 0) return rows;
  const header = parseLine(lines[0]);
  for (let i = 1; i < lines.length; i += 1) {
    const line = lines[i];
    if (!line.trim()) continue;
    const values = parseLine(line);
    const row: CsvRow = {};
    for (let j = 0; j < header.length; j += 1) {
      const key = header[j];
      row[key] = values[j] ?? '';
    }
    rows.push(row);
  }
  return rows;
}

function parseLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];
    if (inQuotes) {
      if (char === '"') {
        if (line[i + 1] === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
  }
  result.push(current);
  return result;
}

function formatValue(value: unknown): string {
  if (typeof value === 'string') {
    const escaped = value.replace(/`/g, '\\`');
    return `\`${escaped}\``;
  }
  if (value === null || value === undefined) return 'null';
  if (Array.isArray(value)) {
    return `[${value.map(formatValue).join(', ')}]`;
  }
  return JSON.stringify(value);
}

function mapObject(obj: Record<string, unknown>): string {
  const entries = Object.entries(obj).map(([key, value]) => `  ${key}: ${formatValue(value)}`);
  return `{
${entries.join(',\n')}
}`;
}

function emitType(name: string, fields: Record<string, unknown>): string {
  const lines = Object.entries(fields).map(([key, value]) => {
    const optional = value === null || value === undefined;
    const tsType = inferType(value);
    return `  ${key}${optional ? '?' : ''}: ${tsType};`;
  });
  return `export type ${name} = {
${lines.join('\n')}
};`;
}

function inferType(value: unknown): string {
  if (typeof value === 'string') return 'string';
  if (typeof value === 'number') return 'number';
  if (typeof value === 'boolean') return 'boolean';
  if (value === null || value === undefined) return 'string | null';
  if (Array.isArray(value)) {
    if (value.length === 0) return 'readonly string[]';
    return `readonly ${inferType(value[0])}[]`;
  }
  return 'unknown';
}

function main() {
  ensureDatasetDir();
  const dataCsv = readFileSync(DATA_FILE, 'utf8');
  const serviceCsv = readFileSync(SOURCE_FILE, 'utf8');
  const macroRows = parseCsv(dataCsv) as MacroEntry[];
  const services = parseCsv(serviceCsv) as ServiceEntry[];

  if (macroRows.length === 0) {
    throw new Error('macro_metric_seed_dataset.csv produced no rows');
  }

  const sampleMacro = macroRows[0];
  const sampleService = services[0];

  const chunks: string[] = [];
  chunks.push('// Auto-generated by scripts/generate-macro-dataset.ts');
  chunks.push('// Do not edit by hand.');
  chunks.push('');
  chunks.push(emitType('MacroMetricEntry', sampleMacro));
  chunks.push(emitType('MacroServiceEntry', sampleService));
  chunks.push('');
  const macroObjects = macroRows.map((row) => mapObject(row as Record<string, unknown>));
  chunks.push(`export const MACRO_METRIC_DATA: readonly MacroMetricEntry[] = [
${macroObjects.join(',\n')}
];`);
  chunks.push('');
  const serviceObjects = services.map((row) => mapObject(row as Record<string, unknown>));
  chunks.push(`export const MACRO_METRIC_SERVICES: readonly MacroServiceEntry[] = [
${serviceObjects.join(',\n')}
];`);
  chunks.push('');

  writeFileSync(OUTPUT_FILE, `${chunks.join('\n')}\n`, 'utf8');
}

main();
